<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Arduino Doc</title>
  <link rel="stylesheet" href="styles/technical-doc.css">
</head>
<body>
  <nav id="navbar">
    <header>Arduino Quick Reference</header>
    <div class="nav-link-group">
    <a href="#introduction" class="nav-link">Introduction</a>
    <a href="#board_types" class="nav-link">Board Types</a>
    <a href="#board_description" class="nav-link">Board Description</a>
    <a href="#installation" class="nav-link">Installation</a>
    <a href="#program_structure" class="nav-link">Program Structure</a>
    <a href="#data_types" class="nav-link">Data Types</a>
    <a href="#variables_and_constants" class="nav-link">Variables and Constants</a>
    <a href="#operators" class="nav-link">Operators</a>
    <a href="#control_statements" class="nav-link">Control Statements</a>
    <a href="#loops" class="nav-link">Loops</a>
    <a href="#functions" class="nav-link">Functions</a>
    <a href="#strings" class="nav-link">Strings</a>
    <a href="#string_object" class="nav-link">String Object</a>
    <a href="#time" class="nav-link">Time</a>
    <a href="#arrays" class="nav-link">Arrays</a>
  </div>
  </nav>
  <main id="main-doc">
    <section id="introduction" class="main-section">
      <header>Introduction</header>
      <p>Arduino is a prototype platform (open-source) based on an easy-to-use hardware and software. It consists of a circuit board, which can be programed (referred to as a microcontroller) and a ready-made software called Arduino IDE (Integrated Development Environment), which is used to write and upload the computer code to the physical board.</p>
  <p>The key features are −</p>
  <ul>
  <li><p>Arduino boards are able to read analog or digital input signals from different sensors and turn it into an output such as activating a motor, turning LED on/off, connect to the cloud and many other actions.</p></li>
  <li><p>You can control your board functions by sending a set of instructions to the microcontroller on the board via Arduino IDE (referred to as uploading software).</p></li>
  <li><p>Unlike most previous programmable circuit boards, Arduino does not need an extra piece of hardware (called a programmer) in order to load a new code onto the board. You can simply use a USB cable.</p></li>
  <li><p>Additionally, the Arduino IDE uses a simplified version of C++, making it easier to learn to program.</p></li>
  <li><p>Finally, Arduino provides a standard form factor that breaks the functions of the micro-controller into a more accessible package.</p></li>
  </ul>
  <img src="images/technical-doc/board.png" alt="Board">
    </section>
    <section id="board_types" class="main-section">
      <header>Board Types</header>

      <p>Various kinds of Arduino boards are available depending on different microcontrollers used. However, all Arduino boards have one thing in common: they are programed through the Arduino IDE.</p>
      <p>The differences are based on the number of inputs and outputs (the number of sensors, LEDs, and buttons you can use on a single board), speed, operating voltage, form factor etc. Some boards are designed to be embedded and have no programming interface (hardware), which you would need to buy separately. Some can run directly from a 3.7V battery, others need at least 5V.</p>
      <p>Here is a list of different Arduino boards available.</p>
      <p ><b>Arduino boards based on ATMEGA328 microcontroller</b></p>
      <table>
      <tr><th>Board Name</th><th>Operating Volt</th><th>Clock Speed</th><th>Digital i/o</th><th>Analog Inputs</th><th>PWM</th><th>UART</th><th>Programming Interface</th></tr>
      
        <tr><td>Arduino Uno R3</td><td>5V</td><td>16MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>USB via ATMega16U2</td></tr>
        <tr><td>Arduino Uno R3 SMD</td><td>5V</td><td>16MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>USB via ATMega16U2</td></tr>
        <tr><td>Red Board</td><td>5V</td><td>16MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>USB via FTDI</td></tr>
        <tr><td>Arduino Pro 3.3v/8 MHz</td><td>3.3V</td><td>8MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>Arduino Pro 5V/16MHz</td><td>5V</td><td>16MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>Arduino mini 05</td><td>5V</td><td>16MHz</td><td>14</td><td>8</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>Arduino Pro mini 3.3v/8mhz</td><td>3.3V</td><td>8MHz</td><td>14</td><td>8</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>Arduino Pro mini 5v/16mhz</td><td>5V</td><td>16MHz</td><td>14</td><td>8</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>Arduino Ethernet</td><td>5V</td><td>16MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>Arduino Fio</td><td>3.3V</td><td>8MHz</td><td>14</td><td>8</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>LilyPad Arduino 328 main board</td><td>3.3V</td><td>8MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>FTDI-Compatible Header</td></tr>
        <tr><td>LilyPad Arduino simple board</td><td>3.3V</td><td>8MHz</td><td>9</td><td>4</td><td>5</td><td>0</td><td>FTDI-Compatible Header</td></tr>
      
      </table>
      <p><b>Arduino boards based on ATMEGA32u4 microcontroller</b></p>
      <table>
        <tr><th >Board Name</th><th >Operating Volt</th><th >Clock Speed</th><th >Digital i/o</th><th >Analog Inputs</th><th >PWM</th><th >UART</th><th >Programming Interface</th></tr>
      <tr><td>Arduino Leonardo</td><td>5V</td><td>16MHz</td><td>20</td><td>12</td><td>7</td><td>1</td><td>Native USB</td></tr>
      <tr><td>Pro micro 5V/16MHz</td><td>5V</td><td>16MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>Native USB</td></tr>
      <tr><td>Pro micro 3.3V/8MHz</td><td>5V</td><td>16MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>Native USB</td></tr>
      <tr><td>LilyPad Arduino USB</td><td>3.3V</td><td>8MHz</td><td>14</td><td>6</td><td>6</td><td>1</td><td>Native USB</td></tr>
      </table>
      <p><b>Arduino boards based on ATMEGA2560 microcontroller</b></p>
      <table>
        <tr><th >Board Name</th><th >Operating Volt</th><th >Clock Speed</th><th >Digital i/o</th><th >Analog Inputs</th><th >PWM</th><th >UART</th><th >Programming Interface</th></tr>
      <tr><td>Arduino Mega 2560 R3</td><td>5V</td><td>16MHz</td><td>54</td><td>16</td><td>14</td><td>4</td><td>USB via ATMega16U2B</td></tr>
      <tr><td>Mega Pro 3.3V</td><td>3.3V</td><td>8MHz</td><td>54</td><td>16</td><td>14</td><td>4</td><td>FTDI-Compatible Header</td></tr>
      <tr><td>Mega Pro 5V</td><td>5V</td><td>16MHz</td><td>54</td><td>16</td><td>14</td><td>4</td><td>FTDI-Compatible Header</td></tr>
      <tr><td>Mega Pro Mini 3.3V</td><td>3.3V</td><td>8MHz</td><td>54</td><td>16</td><td>14</td><td>4</td><td>FTDI-Compatible Header</td></tr>
      </table>
      <p><b>Arduino boards based on AT91SAM3X8E microcontroller</b></p>
      <table>
        <tr><th >Board Name</th><th >Operating Volt</th><th >Clock Speed</th><th >Digital i/o</th><th >Analog Inputs</th><th >PWM</th><th >UART</th><th >Programming Interface</th></tr>
      <tr><td>Arduino Mega 2560 R3</td><td>3.3V</td><td>84MHz</td><td>54</td><td>12</td><td>12</td><td>4</td><td>USB native</td></tr>
      </table>
    </section>
    <section id="board_description" class="main-section">
      <header>Board Description</header>
        <p>In this chapter, we will learn about the different components on the Arduino board. We will study the Arduino UNO board because it is the most popular board in the Arduino board family. In addition, it is the best board to get started with electronics and coding. Some boards look a bit different from the one given below, but most Arduinos have majority of these components in common.</p>
        <img src="images/technical-doc/board_description.png" alt="Board Description">
        <table>
        
          <tr>
            <td>1</td>
            <td>
              <p><b>Power USB</b></p>
              <p>Arduino board can be powered by using the USB cable from your computer. All you need to do is connect the USB cable to the USB connection (1).</p>
            </td>
          </tr>
        <tr>
        <td>2</td>
        <td><p><b>Power (Barrel Jack)</b></p>
        <p>Arduino boards can be powered directly from the AC mains power supply by connecting it to the Barrel Jack (2).</p>
        </td>
        </tr>
        <tr><td>3</td><td><p><b>Voltage Regulator</b></p>
        <p>The function of the voltage regulator is to control the voltage given to the Arduino board and stabilize the DC voltages used by the processor and other elements.</p>
        </td></tr>
        <tr><td>4</td><td><p><b>Crystal Oscillator</b></p>
        <p>The crystal oscillator helps Arduino in dealing with time issues. How does Arduino calculate time? The answer is, by using the crystal oscillator. The number printed on top of the Arduino crystal is 16.000H9H. It tells us that the frequency is 16,000,000 Hertz or 16 MHz.</p>
        </td></tr>
        <tr><td>5? 17</td><td><p><b>Arduino Reset</b></p>
        <p>You can reset your Arduino board, i.e., start your program from the beginning. You can reset the UNO board in two ways. First, by using the reset button (17) on the board. Second, you can connect an external reset button to the Arduino pin labelled RESET (5).</p>
        </td></tr>
        <tr><td>6, 7, 8, 9</td><td><p><b>Pins (3.3, 5, GND, Vin)</b></p>
        <ul>
        <li><p>3.3V (6) − Supply 3.3 output volt</p></li>
        <li><p>5V (7) − Supply 5 output volt</p></li>
        <li><p>Most of the components used with Arduino board works fine with 3.3 volt and 5 volt.</p></li>
        <li><p>GND (8)(Ground) − There are several GND pins on the Arduino, any of which can be used to ground your circuit.</p></li>
        <li><p>Vin (9) − This pin also can be used to power the Arduino board from an external power source, like AC mains power supply.</p></li>
        </ul>
        </td></tr>
        <tr><td>10</td><td><p><b>Analog pins</b></p>
        <p>The Arduino UNO board has five analog input pins A0 through A5. These pins can read the signal from an analog sensor like the humidity sensor or temperature sensor and convert it into a digital value that can be read by the microprocessor.</p>
        </td></tr>
        <tr><td>11</td><td><p><b>Main microcontroller</b></p>
        <p>Each Arduino board has its own microcontroller (11). You can assume it as the brain of your board. The main IC (integrated circuit) on the Arduino is slightly different from board to board. The microcontrollers are usually of the ATMEL Company. You must know what IC your board has before loading up a new program from the Arduino IDE. This information is available on the top of the IC. For more details about the IC construction and functions, you can refer to the data sheet.</p>
        </td></tr>
        <tr><td>12</td>
        <td><p><b>ICSP pin</b></p>
        <p>Mostly, ICSP (12) is an AVR, a tiny programming header for the Arduino consisting of MOSI, MISO, SCK, RESET, VCC, and GND. It is often referred to as an SPI (Serial Peripheral Interface), which could be considered as an "expansion" of the output. Actually, you are slaving the output device to the master of the SPI bus.</p>
        </td></tr>
        <tr><td>13</td><td><p><b>Power LED indicator</b></p>
        <p>This LED should light up when you plug your Arduino into a power source to indicate that your board is powered up correctly. If this light does not turn on, then there is something wrong with the connection.</p>
        </td></tr>
        <tr><td>14</td><td><p><b>TX and RX LEDs</b></p>
        <p>On your board, you will find two labels: TX (transmit) and RX (receive). They appear in two places on the Arduino UNO board. First, at the digital pins 0 and 1, to indicate the pins responsible for serial communication. Second, the TX and RX led (13). The TX led flashes with different speed while sending the serial data. The speed of flashing depends on the baud rate used by the board. RX flashes during the receiving process.</p>
        </td></tr>
        <tr><td>15</td><td><p><b>Digital I/O</b></p>
        <p>The Arduino UNO board has 14 digital I/O pins (15) (of which 6 provide PWM (Pulse Width Modulation) output. These pins can be configured to work as input digital pins to read logic values (0 or 1) or as digital output pins to drive different modules like LEDs, relays, etc. The pins labeled “~” can be used to generate PWM.</p>
        </td></tr>
        <tr><td>16</td><td><p><b>AREF</b></p>
        <p>AREF stands for Analog Reference. It is sometimes, used to set an external reference voltage (between 0 and 5 Volts) as the upper limit for the analog input pins.</p>
        </td></tr>
        </table>
    </section>
    <section class="main-section" id="installation">
      <header>Installation</header>
      <p>After learning about the main parts of the Arduino UNO board, we are ready to learn how to set up the Arduino IDE. Once we learn this, we will be ready to upload our program on the Arduino board.</p>
      <p>In this section, we will learn in easy steps, how to set up the Arduino IDE on our computer and prepare the board to receive the program via USB cable.</p>
      <p><b>Step 1</b> − First you must have your Arduino board (you can choose your favorite board) and a USB cable. In case you use Arduino UNO, Arduino Duemilanove, Nano, Arduino Mega 2560, or Diecimila, you will need a standard USB cable (A plug to B plug), the kind you would connect to a USB printer as shown in the following image.</p>
      <p>In case you use Arduino Nano, you will need an A to Mini-B cable instead as shown in the following image.</p>
      <p><b>Step 2 − Download Arduino IDE Software.</b></p>
      <p>You can get different versions of Arduino IDE from the <a href="https://www.arduino.cc/en/Main/Software" target="_blank">Download page</a> on the Arduino Official website. You must select your software, which is compatible with your operating system (Windows, IOS, or Linux). After your file download is complete, unzip the file.</p>
      <p><b>Step 3 − Power up your board.</b></p>
      <p>The Arduino Uno, Mega, Duemilanove and Arduino Nano automatically draw power from either, the USB connection to the computer or an external power supply. If you are using an Arduino Diecimila, you have to make sure that the board is configured to draw power from the USB connection. The power source is selected with a jumper, a small piece of plastic that fits onto two of the three pins between the USB and power jacks. Check that it is on the two pins closest to the USB port.</p>
      <p>Connect the Arduino board to your computer using the USB cable. The green power LED (labeled PWR) should glow.</p>
      <p><b>Step 4 − Launch Arduino IDE.</b></p>
      <p>After your Arduino IDE software is downloaded, you need to unzip the folder. Inside the folder, you can find the application icon with an infinity label (application.exe). Double-click the icon to start the IDE.</p>
      <p><b>Step 5 − Open your first project.</b></p>
      <p>Once the software starts, you have two options −</p>
      <ul>
        <li>Create a new project.</li>
        <li>Open an existing project example.</li>
      </ul>
      <p>To create a new project, select File → <b>New</b>.</p>
      <img src="images/technical-doc/edit_file.png" alt="Edit File">
      <p>To open an existing project example, select File → Example → Basics → Blink.</p>
      <p>Here, we are selecting just one of the examples with the name <b>Blink</b>. It turns the LED on and off with some time delay. You can select any other example from the list.</p>
      <p><b>Step 6 − Select your Arduino board.</b></p>
      <p>To avoid any error while uploading your program to the board, you must select the correct Arduino board name, which matches with the board connected to your computer.</p>
      <p>Go to Tools → Board and select your board.</p>
      <img src="images/technical-doc/select_board.png" alt="Select Board">
      <p>Here, we have selected Arduino Uno board according to our tutorial, but you must select the name matching the board that you are using.</p>
      <p><b>Step 7 − Select your serial port.</b></p>
      <p>Select the serial device of the Arduino board. Go to <b>Tools → Serial Port</b> menu. This is likely to be COM3 or higher (COM1 and COM2 are usually reserved for hardware serial ports). To find out, you can disconnect your Arduino board and re-open the menu, the entry that disappears should be of the Arduino board. Reconnect the board and select that serial port.</p>
      <img src="images/technical-doc/serial_port.png" alt="Serial Port">
      <p><b>Step 8 − Upload the program to your board.</b></p>
      <p>Before explaining how we can upload our program to the board, we must demonstrate the function of each symbol appearing in the Arduino IDE toolbar.</p>
      <img src="images/technical-doc/upload_program.png" alt="Upload program">
      <p><b>A</b> − Used to check if there is any compilation error.</p>
      <p><b>B</b> − Used to upload a program to the Arduino board.</p>
      <p><b>C</b> − Shortcut used to create a new sketch.</p>
      <p><b>D</b> − Used to directly open one of the example sketch.</p>
      <p><b>E</b> − Used to save your sketch.</p>
      <p><b>F</b> − Serial monitor used to receive serial data from the board and send the serial data to the board.</p>
      <p>Now, simply click the "Upload" button in the environment. Wait a few seconds; you will see the RX and TX LEDs on the board, flashing. If the upload is successful, the message "Done uploading" will appear in the status bar.</p>
      <p><b>Note</b> − If you have an Arduino Mini, NG, or other board, you need to press the reset button physically on the board, immediately before clicking the upload button on the Arduino Software.</p>
    </section>
    <section class="main-section" id="program_structure" >
      <header>Program Structure</header>
  <p>In this chapter, we will study in depth, the Arduino program structure and we will learn more new terminologies used in the Arduino world. The Arduino software is open-source. The source code for the Java environment is released under the GPL and the C/C++ microcontroller libraries are under the LGPL.</p>
  <p><b>Sketch</b> − The first new terminology is the Arduino program called “<b>sketch</b>”.</p>
  <p><b>Structure</b></p>
  <p>Arduino programs can be divided in three main parts: <b>Structure, Values</b> (variables and constants), and <b>Functions</b>. In this tutorial, we will learn about the Arduino software program, step by step, and how we can write the program without any syntax or compilation error.</p>
  <p>Let us start with the <b>Structure</b>. Software structure consist of two main functions −</p>
  <ul>
  <li>Setup( ) function</li>
  <li>Loop( ) function</li>
  </ul>
  <img src="images/technical-doc/structure.png" alt="Structure">
  <code><pre> setup ( ) {
  
  }</pre>
  </code>
  <ul>
  <li><p><b>PURPOSE</b> − The <b>setup()</b> function is called when a sketch starts. Use it to initialize the variables, pin modes, start using libraries, etc. The setup function will only run once, after each power up or reset of the Arduino board.</p></li>
  </ul>
  <code><pre>Void Loop ( ) {
  
  }
  </pre></code>
  <ul>
  <li><p><b>PURPOSE</b> − After creating a <b>setup()</b> function, which initializes and sets the initial values, the <b>loop()</b> function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond. Use it to actively control the Arduino board.</p></li>
  </ul>
    </section>
    <section class="main-section" id="data_types">
      <header>Data Types</header>
      <p>Data types in C refers to an extensive system used for declaring variables or functions of different types. The type of a variable determines how much space it occupies in the storage and how the bit pattern stored is interpreted.</p>
      <p>The following table provides all the data types that you will use during Arduino programming.</p>
      <table>
        <tr><td>void</td><td>Boolean</td><td>char</td><td>Unsigned char</td><td>byte</td><td>int</td><td>Unsigned int</td><td>word</td></tr>
      <tr><td>long</td><td>Unsigned long</td><td>short</td><td>float</td><td>double</td><td>array</td><td>String-char array</td><td>String-object</td></tr>
      </table>
      <h2>void</h2>
      <p>The void keyword is used only in function declarations. It indicates that the function is expected to return no information to the function from which it was called.</p>
      <h3>Example</h3>
      <code><pre>Void Loop ( ) {
         // rest of the code
      }
      </pre></code>
      <h2>Boolean</h2>
      <p>A Boolean holds one of two values, true or false. Each Boolean variable occupies one byte of memory.</p>
      <h3>Example</h3>
      <code><pre>boolean val = false ; // declaration of variable with type boolean and initialize it with false
      boolean state = true ; // declaration of variable with type boolean and initialize it with true
      </pre></code>
      <h2>Char</h2>
      <p>A data type that takes up one byte of memory that stores a character value. Character literals are written in single quotes like this: 'A' and for multiple characters, strings use double quotes: "ABC".</p>
      <p>However, characters are stored as numbers. You can see the specific encoding in the <a href="https://www.arduino.cc/en/Reference/ASCIIchart" rel="nofollow" target="_blank">ASCII chart</a>. This means that it is possible to do arithmetic operations on characters, in which the ASCII value of the character is used. For example, 'A' + 1 has the value 66, since the ASCII value of the capital letter A is 65.</p>
      <h3>Example</h3>
      <code><pre>Char chr_a = ‘a’ ;//declaration of variable with type char and initialize it with character a
      Char chr_c = 97 ;//declaration of variable with type char and initialize it with character 97
      </pre></code>
      <p></p>
      <img src="/arduino/images/ascii_char_table.jpg" alt="ASCII Char Table">
      <h2>unsigned char</h2>
      <p><b>Unsigned char</b> is an unsigned data type that occupies one byte of memory. The unsigned char data type encodes numbers from 0 to 255.</p>
      <h3>Example</h3>
      <code><pre>Unsigned Char chr_y = 121 ; // declaration of variable with type Unsigned char and initialize it with character y
      </pre></code>
      <h2>byte</h2>
      <p>A byte stores an 8-bit unsigned number, from 0 to 255.</p>
      <h3>Example</h3>
      <code><pre>byte m = 25 ;//declaration of variable with type byte and initialize it with 25
      </pre></code>
      <h2>int</h2>
      <p>Integers are the primary data-type for number storage. int stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2^15 and a maximum value of (2^15) - 1).</p>
      <p>The <b>int</b> size varies from board to board. On the Arduino Due, for example, an <b>int</b> stores a 32-bit (4-byte) value. This yields a range of -2,147,483,648 to 2,147,483,647 (minimum value of -2^31 and a maximum value of (2^31) - 1).</p>
      <h3>Example</h3>
      <code><pre>int counter = 32 ;// declaration of variable with type int and initialize it with 32
      </pre></code>
      <h2>Unsigned int</h2>
      <p>Unsigned ints (unsigned integers) are the same as int in the way that they store a 2 byte value. Instead of storing negative numbers, however, they only store positive values, yielding a useful range of 0 to 65,535 (2^16) - 1). The Due stores a 4 byte (32-bit) value, ranging from 0 to 4,294,967,295 (2^32 - 1).</p>
      <h3>Example</h3>
      <code><pre>Unsigned int counter = 60 ; // declaration of variable with 
         type unsigned int and initialize it with 60
      </pre></code>
      <h2>Word</h2>
      <p>On the Uno and other ATMEGA based boards, a word stores a 16-bit unsigned number. On the Due and Zero, it stores a 32-bit unsigned number.</p>
      <h3>Example</h3>
      <code><pre>word w = 1000 ;//declaration of variable with type word and initialize it with 1000
      </pre></code>
      <h2>Long</h2>
      <p>Long variables are extended size variables for number storage, and store 32 bits (4 bytes), from -2,147,483,648 to 2,147,483,647.</p>
      <h3>Example</h3>
      <code><pre>Long velocity = 102346 ;//declaration of variable with type Long and initialize it with 102346
      </pre></code>
      <h2>unsigned long</h2>
      <p>Unsigned long variables are extended size variables for number storage and store 32 bits (4 bytes). Unlike standard longs, unsigned longs will not store negative numbers, making their range from 0 to 4,294,967,295 (2^32 - 1).</p>
      <h3>Example</h3>
      <code><pre>Unsigned Long velocity = 101006 ;// declaration of variable with 
         type Unsigned Long and initialize it with 101006
      </pre></code>
      <h2>short</h2>
      <p>A short is a 16-bit data-type. On all Arduinos (ATMega and ARM based), a short stores a 16-bit (2-byte) value. This yields a range of -32,768 to 32,767 (minimum value of -2^15 and a maximum value of (2^15) - 1).</p>
      <h3>Example</h3>
      <code><pre>short val = 13 ;//declaration of variable with type short and initialize it with 13
      </pre></code>
      <h2>float</h2>
      <p>Data type for floating-point number is a number that has a decimal point. Floating-point numbers are often used to approximate the analog and continuous values because they have greater resolution than integers.</p>
      <p>Floating-point numbers can be as large as 3.4028235E+38 and as low as -3.4028235E+38. They are stored as 32 bits (4 bytes) of information.</p>
      <h3>Example</h3>
      <code><pre>float num = 1.352;//declaration of variable with type float and initialize it with 1.352
      </pre></code>
      <h2>double</h2>
      <p>On the Uno and other ATMEGA based boards, Double precision floating-point number occupies four bytes. That is, the double implementation is exactly the same as the float, with no gain in precision. On the Arduino Due, doubles have 8-byte (64 bit) precision.</p>
      <h3>Example</h3>
      <code><pre>double num = 45.352 ;// declaration of variable with type double and initialize it with 45.352
      </pre></code>
    </section>
    <section class="main-section" id="variables_and_constants">
      <header>Variables and Constants</header>
      <p>Before we start explaining the variable types, a very important subject we need to make sure, you fully understand is called the <b>variable scope</b>.</p>
      <h2>What is Variable Scope?</h2>
      <p>Variables in C programming language, which Arduino uses, have a property called scope. A scope is a region of the program and there are three places where variables can be declared. They are −</p>
      <ul>
      <li>Inside a function or a block, which is called <b>local variables</b>.</li>
      <li>In the definition of function parameters, which is called <b>formal parameters</b>.</li>
      <li>Outside of all functions, which is called <b>global variables</b>.</li>
      </ul>
      <h3>Local Variables</h3>
      <p>Variables that are declared inside a function or block are local variables. They can be used only by the statements that are inside that function or block of code. Local variables are not known to function outside their own. Following is the example using local variables −</p>
      <code><pre>Void setup () {
      
      }
      
      Void loop () {
         int x , y ;
         int z ; Local variable declaration
         x = 0;
         y = 0; actual initialization
         z = 10;
      }
      </pre></code>
      <h3>Global Variables</h3>
      <p>Global variables are defined outside of all the functions, usually at the top of the program. The global variables will hold their value throughout the life-time of your program.</p>
      <p>A global variable can be accessed by any function. That is, a global variable is available for use throughout your entire program after its declaration.</p>
      <p>The following example uses global and local variables −</p>
      <code><pre>Int T , S ;
      float c = 0 ; Global variable declaration
      
      Void setup () {
      
      }
      
      Void loop () {
         int x , y ;
         int z ; Local variable declaration
         x = 0;
         y = 0; actual initialization
         z = 10;
      }
      </pre></code>
    </section>
    <section class="main-section" id="operators">
      <header>Operators</header>
  <p>An operator is a symbol that tells the compiler to perform specific mathematical or logical functions. C language is rich in built-in operators and provides the following types of operators −</p>
  <ul>
  <li>Arithmetic Operators</li>
  <li>Comparison Operators</li>
  <li>Boolean Operators</li>
  <li>Bitwise Operators</li>
  <li>Compound Operators</li>
  </ul>
  <h2>Arithmetic Operators</h2>
  <p>Assume variable A holds 10 and variable B holds 20 then −</p>
  <table>
  <tr><th >Operator name</th><th >Operator simple</th><th >Description</th><th >Example</th></tr>
    <tr><td>assignment operator</td><td>=</td><td>Stores the value to the right of the equal sign in the variable to the left of the equal sign.</td>  <td>A = B</td></tr>
  <tr><td>addition</td><td>+</td><td>Adds two operands</td><td>A + B will give 30</td></tr>
  <tr><td>subtraction</td><td>-</td><td>Subtracts second operand from the first</td><td>A - B will give -10</td></tr>
  <tr><td>multiplication</td><td>*</td><td>Multiply both operands</td><td>A * B will give 200</td></tr>
  <tr><td>division</td><td>/</td><td>Divide numerator by denominator</td><td>B / A will give 2</td></tr>
  <tr><td>modulo</td><td>%</td><td>Modulus Operator and remainder of after an integer division</td><td>B % A will give 0</td></tr>
  </table>
  <h2>Comparison Operators</h2>
  <p>Assume variable A holds 10 and variable B holds 20 then −</p>
  <table>
  <tr><th >Operator name</th><th >Operator simple</th><th >Description</th><th >Example</th></tr>
  <tr><td>equal to</td><td>==</td><td>Checks if the value of two operands is equal or not, if yes then condition becomes true.</td><td>(A == B) is not true</td></tr>
  <tr><td>not equal to</td><td>!=</td><td>Checks if the value of two operands is equal or not, if values are not equal then condition becomes true.</td><td>(A != B) is true</td></tr>
  <tr><td>less than</td><td>&lt;</td><td>Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.</td><td>(A &lt; B) is true</td></tr>
  <tr><td>greater than</td><td>&gt;</td><td>Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.</td><td>(A &gt; B) is not true</td></tr>
  <tr><td>less than or equal to</td><td>&lt;=</td><td>Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.</td><td>(A &lt;= B) is true</td></tr>
  <tr><td>greater than or equal to</td><td>&gt;=</td><td>Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td><td>(A &gt;= B) is not true</td></tr>
  </table>
  <h2>Boolean Operators</h2>
  <p>Assume variable A holds 10 and variable B holds 20 then −</p>
  <table>
  <tr><th >Operator name</th><th >Operator simple</th><th >Description</th><th >Example</th></tr>
  <tr><td>and</td><td>&amp;&amp;</td><td>Called Logical AND operator. If both the operands are non-zero then then condition becomes true.</td><td>(A &amp;&amp; B) is true</td></tr>
  <tr><td>or</td><td>||</td><td>Called Logical OR Operator. If any of the two operands is non-zero then then condition becomes true.</td><td>(A || B) is true</td></tr>
  <tr><td>not</td><td>!</td><td>Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.</td><td>!(A &amp;&amp; B) is false</td></tr>
  </table>
  <h2>Bitwise Operators</h2>
  <p>Assume variable A holds 60 and variable B holds 13 then −</p>
  <table>
  <tr><th >Operator name</th><th >Operator simple</th>  <th >Description</th><th >Example</th></tr>
  <tr><td>and</td><td>&amp;</td><td>Binary AND Operator copies a bit to the result if it exists in both operands.</td><td>(A &amp; B) will give 12 which is 0000 1100</td></tr><tr>
  <td>or</td><td>|</td><td>Binary OR Operator copies a bit if it exists in either operand</td><td>(A | B) will give 61 which is 0011 1101</td></tr>
  <tr><td>xor</td><td>^</td><td>Binary XOR Operator copies the bit if it is set in one operand but not both.</td><td>(A ^ B) will give 49 which is 0011 0001</td></tr>
  <tr><td>not</td><td>~</td><td>Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.</td><td>(~A ) will give -60 which is 1100 0011</td></tr>
  <tr><td>shift left</td><td>&lt;&lt;</td><td>Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.</td><td>A &lt;&lt; 2 will give 240 which is 1111 0000</td></tr>
  <tr><td>shift right</td><td>&gt;&gt;</td><td>Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.</td><td>A &gt;&gt; 2 will give 15 which is 0000 1111</td></tr>
  </table>
  <h2>Compound Operators</h2>
  <p>Assume variable A holds 10 and variable B holds 20 then −</p>
  <table>
  <tr><th >Operator name</th><th >Operator simple</th><th >Description</th><th >Example</th></tr>
  <tr><td>increment</td>  <td>++</td>  <td>Increment operator, increases integer value by one</td><td>A++ will give 11</td></tr>
  <tr><td>decrement</td><td>--</td><td>Decrement operator, decreases integer value by one</td><td>A-- will give 9</td></tr>
  <tr><td>compound addition</td>  <td>+=</td><td>Add AND assignment operator. It adds right operand to the left operand and assign the result to left operand</td><td>B += A is equivalent to B = B+ A</td></tr>
  <tr><td>compound subtraction</td><td>-=</td><td>Subtract AND assignment operator. It subtracts right operand from the left operand and assign the result to left operand</td><td>B -= A is equivalent to B = B - A</td></tr>
  <tr><td>compound multiplication</td><td>*=</td><td>Multiply AND assignment operator. It multiplies right operand with the left operand and assign the result to left operand</td><td>B*= A is equivalent to B = B* A</td></tr>
  <tr><td>compound division</td><td>/=</td><td>Divide AND assignment operator. It divides left operand with the right operand and assign the result to left operand</td><td>B /= A is equivalent to B = B / A</td></tr>
  <tr><td>compound modulo</td><td>%=</td><td>Modulus AND assignment operator. It takes modulus using two operands and assign the result to left operand</td>
  <td>B %= A is equivalent to B = B % A</td></tr>
  <tr><td>compound bitwise or</td><td>|=</td><td>bitwise inclusive OR and assignment operator</td><td>A |= 2 is same as A = A | 2</td></tr>
  <tr><td>compound bitwise and</td><td>&amp;=</td><td>Bitwise AND assignment operator</td><td>A &amp;= 2 is same as A = A &amp; 2</td></tr>
  </table>
    </section>
    <section class="main-section" id="control_statements">
      <header>Control Statements</header>
      <p>Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program. It should be along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.</p>
      <p>Following is the general form of a typical decision making structure found in most of the programming languages −</p>
      <p>Control Statements are elements in Source Code that control the flow of program execution. They are −</p>
      <table>
      <tr><th>S.NO.</th><th>Control Statement &amp; Description</th></tr>
      <tr><td>1</td><td>
      <p>It takes an expression in parenthesis and a statement or block of statements. If the expression is true then the statement or block of statements gets executed otherwise these statements are skipped.</p>
      </td>
      </tr>
      <tr><td>2</td><td><p>An <b>if</b> statement can be followed by an optional else statement, which executes when the expression is false.</p></td>
      </tr><tr><td>3</td><td><p>The <b>if</b> statement can be followed by an optional <b>else if...else</b> statement, which is very useful to test various conditions using single if...else if statement.</p></td></tr>
      <tr><td>4</td><td>
      <p>Similar to the if statements, <b>switch...case</b> controls the flow of programs by allowing the programmers to specify different codes that should be executed in various conditions.</p></td></tr>
      <tr><td>5</td><td><p>The conditional operator ? : is the only ternary operator in C.</p></td></tr>
      </table>
      
    </section>
    <section class="main-section" id="loops">
      <header>Loops</header>
      <p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
      <p>A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −</p>
      <img src="/arduino/images/loop_architecture.jpg" alt="Loop Architecture">
      <p>C programming language provides the following types of loops to handle looping requirements.</p>
      <table>
      <tr><th>S.NO.</th><th >Loop &amp; Description</th></tr>
        <tr><td>1</td><td><p>while loops will loop continuously, and infinitely, until the expression inside the parenthesis, () becomes false. Something must change the tested variable, or the while loop will never exit.</p></td></tr>
      <tr><td>2</td><td><p>The <b>do…while</b> loop is similar to the while loop. In the while loop, the loop-continuation condition is tested at the beginning of the loop before performed the body of the loop.</p></td></tr>
      <tr><td>3</td><td><p>A <b>for loop</b> executes statements a predetermined number of times. The control expression for the loop is initialized, tested and manipulated entirely within the for loop parentheses.</p></td></tr>
      <tr><td>4</td><td><p>C language allows you to use one loop inside another loop. The following example illustrates the concept.</p></td></tr>
      <tr><td>5</td><td><p>It is the loop having no terminating condition, so the loop becomes infinite.</p></td></tr>
      </table>
    </section>
    <section class="main-section" id="functions">
      <header>Functions</header>
      <p>Functions allow structuring the programs in segments of code to perform individual tasks. The typical case for creating a function is when one needs to perform the same action multiple times in a program.</p>
      <p>Standardizing code fragments into functions has several advantages −</p>
      <ul>
      <li><p>Functions help the programmer stay organized. Often this helps to conceptualize the program.</p></li>
      <li><p>Functions codify one action in one place so that the function only has to be thought about and debugged once.</p></li>
      <li><p>This also reduces chances for errors in modification, if the code needs to be changed.</p></li>
      <li><p>Functions make the whole sketch smaller and more compact because sections of code are reused many times.</p></li>
      <li><p>They make it easier to reuse code in other programs by making it modular, and using functions often makes the code more readable.</p></li>
      </ul>
      <p>There are two required functions in an Arduino sketch or a program i.e. setup () and loop(). Other functions must be created outside the brackets of these two functions.</p>
      <p>The most common syntax to define a function is −</p>
      <img src="images/technical-doc/function.png" alt="Function">
      <h2>Function Declaration</h2>
      <p>A function is declared outside any other functions, above or below the loop function.</p>
      <p>We can declare the function in two different ways −</p>
      <p>The first way is just writing the part of the function called <b>a function prototype</b> above the loop function, which consists of −</p>
      <ul>
      <li>Function return type</li>
      <li>Function name</li>
      <li>Function argument type, no need to write the argument name</li>
      </ul>
      <p>Function prototype must be followed by a semicolon ( ; ).</p>
      <p>The following example shows the demonstration of the function declaration using the first method.</p>
      <h3>Example</h3>
      <code><pre>int sum_func (int x, int y) // function declaration {
         int z = 0;
         z = x+y ;
         return z; // return the value
      }
      
      void setup () {
         Statements // group of statements
      }
      
      Void loop () {
         int result = 0 ;
         result = Sum_func (5,6) ; // function call
      }
      </pre></code>
      <p>The second part, which is called the function definition or declaration, must be declared below the loop function, which consists of −</p>
      <ul>
      <li>Function return type</li>
      <li>Function name</li>
      <li>Function argument type, here you must add the argument name</li>
      <li>The function body (statements inside the function executing when the function is called)</li>
      </ul>
      <p>The following example demonstrates the declaration of function using the second method.</p>
      <h3>Example</h3>
      <code><pre>int sum_func (int , int ) ; // function prototype
      
      void setup () {
         Statements // group of statements
      }
      
      Void loop () {
         int result = 0 ;
         result = Sum_func (5,6) ; // function call
      }
      
      int sum_func (int x, int y) // function declaration {
         int z = 0;
         z = x+y ;
         return z; // return the value
      }
      </pre></code>
      <p>The second method just declares the function above the loop function.</p>
    </section>
    <section class="main-section" id="strings">
      <header>Strings</header>
      <p>Strings are used to store text. They can be used to display text on an LCD or in the Arduino IDE Serial Monitor window. Strings are also useful for storing the user input. For example, the characters that a user types on a keypad connected to the Arduino.</p>
      <p>There are two types of strings in Arduino programming −</p>
      <ul>
      <li>Arrays of characters, which are the same as the strings used in C programming.</li>
      <li>The Arduino String, which lets us use a string object in a sketch.</li>
      </ul>
      <p>In this chapter, we will learn Strings, objects and the use of strings in Arduino sketches. By the end of the chapter, you will learn which type of string to use in a sketch.</p>
      <h2>String Character Arrays</h2>
      <p>The first type of string that we will learn is the string that is a series of characters of the type <b>char</b>. In the previous chapter, we learned what an array is; a consecutive series of the same type of variable stored in memory. A string is an array of char variables.</p>
      <p>A string is a special array that has one extra element at the end of the string, which always has the value of 0 (zero). This is known as a "null terminated string".</p>
      <h3>String Character Array Example</h3>
      <p>This example will show how to make a string and print it to the serial monitor window.</p>
      <p><b>Example</b></p>
      <code><pre>void setup() {
         char my_str[6]; // an array big enough for a 5 character string
         Serial.begin(9600);
         my_str[0] = 'H'; // the string consists of 5 characters
         my_str[1] = 'e';
         my_str[2] = 'l';
         my_str[3] = 'l';
         my_str[4] = 'o';
         my_str[5] = 0; // 6th array element is a null terminator
         Serial.println(my_str);
      }
      
      void loop() { 
      
      }
      </pre></code>
      <p>The following example shows what a string is made up of; a character array with printable characters and 0 as the last element of the array to show that this is where the string ends. The string can be printed out to the Arduino IDE Serial Monitor window by using <b>Serial.println()</b> and passing the name of the string.</p>
      <p>This same example can be written in a more convenient way as shown below −</p>
      <p><b>Example</b></p>
      <code><pre>void setup() {
         char my_str[] = "Hello";
         Serial.begin(9600);
         Serial.println(my_str);
      }
      
      void loop() {
      
      }
      </pre></code>
      <p>In this sketch, the compiler calculates the size of the string array and also automatically null terminates the string with a zero. An array that is six elements long and consists of five characters followed by a zero is created exactly the same way as in the previous sketch.</p>
      <h2>Manipulating String Arrays</h2>
      <p>We can alter a string array within a sketch as shown in the following sketch.</p>
      <h3>Example</h3>
      <code><pre>void setup() {
         char like[] = "I like coffee and cake"; // create a string
         Serial.begin(9600);
         // (1) print the string
         Serial.println(like);
         // (2) delete part of the string
         like[13] = 0;
         Serial.println(like);
         // (3) substitute a word into the string
         like[13] = ' '; // replace the null terminator with a space
         like[18] = 't'; // insert the new word
         like[19] = 'e';
         like[20] = 'a';
         like[21] = 0; // terminate the string
         Serial.println(like);
      }
      
      void loop() {
      
      }
      </pre></code>
      <h3>Result</h3>
      <code><pre>I like coffee and cake
      I like coffee
      I like coffee and tea
      </pre></code>
      <p>The sketch works in the following way.</p>
      <h3>Creating and Printing the String</h3>
      <p>In the sketch given above, a new string is created and then printed for display in the Serial Monitor window.</p>
      <h3>Shortening the String</h3>
      <p>The string is shortened by replacing the 14th character in the string with a null terminating zero (2). This is element number 13 in the string array counting from 0.</p>
      <p>When the string is printed, all the characters are printed up to the new null terminating zero. The other characters do not disappear; they still exist in the memory and the string array is still the same size. The only difference is that any function that works with strings will only see the string up to the first null terminator.</p>
      <h3>Changing a Word in the String</h3>
      <p>Finally, the sketch replaces the word "cake" with "tea" (3). It first has to replace the null terminator at like[13] with a space so that the string is restored to the originally created format.</p>
      <p>New characters overwrite "cak" of the word "cake" with the word "tea". This is done by overwriting individual characters. The 'e' of "cake" is replaced with a new null terminating character. The result is that the string is actually terminated with two null characters, the original one at the end of the string and the new one that replaces the 'e' in "cake". This makes no difference when the new string is printed because the function that prints the string stops printing the string characters when it encounters the first null terminator.</p>
      <h2>Functions to Manipulate String Arrays</h2>
      <p>The previous sketch manipulated the string in a manual way by accessing individual characters in the string. To make it easier to manipulate string arrays, you can write your own functions to do so, or use some of the string functions from the <b>C</b> language library.</p>
      <label>Given below is the list Functions to Manipulate String Arrays</label>
      <table>
      <tr><th>S.No.</th>
      <th >Functions &amp; Description</th>
      </tr>
      <tr>
      <td>1</td>
      <td>
      <p><b>String()</b></p>
      <p>The String class, part of the core as of version 0019, allows you to use and manipulate strings of text in more complex ways than character arrays do. You can concatenate Strings, append to them, search for and replace substrings, and more. It takes more memory than a simple character array, but it is also more useful.</p>
      <p>For reference, character arrays are referred to as strings with a small ‘s’, and instances of the String class are referred to as Strings with a capital S. Note that constant strings, specified in "double quotes" are treated as char arrays, not instances of the String class</p>
      </td>
      </tr>
      <tr>
      <td>2</td>
      <td>
      <p><b>charAt()</b></p>
      <p>Access a particular character of the String.</p>
      </td>
      </tr>
      <tr>
      <td>3</td>
      <td>
      <p><b>compareTo()</b></p>
      <p>Compares two Strings, testing whether one comes before or after the other, or whether they are equal. The strings are compared character by character, using the ASCII values of the characters. That means, for example, 'a' comes before 'b' but after 'A'. Numbers come before letters.</p>
      </td>
      </tr>
      <tr>
      <td>4</td>
      <td>
      <p><b>concat()</b></p>
      <p>Appends the parameter to a String.</p>
      </td>
      </tr>
      <tr>
      <td>5</td>
      <td>
      <p><b>c_str()</b></p>
      <p>Converts the contents of a string as a C-style, null-terminated string. Note that this gives direct access to the internal String buffer and should be used with care. In particular, you should never modify the string through the pointer returned. When you modify the String object, or when it is destroyed, any pointer previously returned by c_str() becomes invalid and should not be used any longer.</p>
      </td>
      </tr>
      <tr>
      <td>6</td>
      <td>
      <p><b>endsWith()</b></p>
      <p>Tests whether or not a String ends with the characters of another String.</p>
      </td>
      </tr>
      <tr>
      <td>7</td>
      <td>
      <p><b>equals()</b></p>
      <p>Compares two strings for equality. The comparison is case-sensitive, meaning the String "hello" is not equal to the String "HELLO".</p>
      </td>
      </tr>
      <tr>
      <td>8</td>
      <td>
      <p><b>equalsIgnoreCase()</b></p>
      <p>Compares two strings for equality. The comparison is not case-sensitive, meaning the String("hello") is equal to the String("HELLO").</p>
      </td>
      </tr>
      <tr>
      <td>9</td>
      <td>
      <p><b>getBytes()</b></p>
      <p>Copies the string's characters to the supplied buffer.</p>
      </td>
      </tr>
      <tr>
      <td>10</td>
      <td>
      <p><b>indexOf()</b></p>
      <p>Locates a character or String within another String. By default, it searches from the beginning of the String, but can also start from a given index, allowing to locate all instances of the character or String.</p>
      </td>
      </tr>
      <tr>
      <td>11</td>
      <td>
      <p><b>lastIndexOf()</b></p>
      <p>Locates a character or String within another String. By default, it searches from the end of the String, but can also work backwards from a given index, allowing to locate all instances of the character or String.</p>
      </td>
      </tr>
      <tr>
      <td>12</td>
      <td>
      <p><b>length()</b></p>
      <p>Returns the length of the String, in characters. (Note that this does not include a trailing null character.)</p>
      </td>
      </tr>
      <tr>
      <td>13</td>
      <td>
      <p><b>remove()</b></p>
      <p>Modify in place, a string removing chars from the provided index to the end of the string or from the provided index to index plus count.</p>
      </td>
      </tr>
      <tr>
      <td>14</td>
      <td>
      <p><b>replace()</b></p>
      <p>The String replace() function allows you to replace all instances of a given character with another character. You can also use replace to replace substrings of a string with a different substring.</p>
      </td>
      </tr>
      <tr>
      <td>15</td>
      <td>
      <p><b>reserve()</b></p>
      <p>The String reserve() function allows you to allocate a buffer in memory for manipulating strings.</p>
      </td>
      </tr>
      <tr>
      <td>16</td>
      <td>
      <p><b>setCharAt()</b></p>
      <p>Sets a character of the String. Has no effect on indices outside the existing length of the String.</p>
      </td>
      </tr>
      <tr>
      <td>17</td>
      <td>
      <p><b>startsWith()</b></p>
      <p>Tests whether or not a String starts with the characters of another String.</p>
      </td>
      </tr>
      <tr>
      <td>18</td>
      <td>
      <p><b>toCharArray()</b></p>
      <p>Copies the string's characters to the supplied buffer.</p>
      </td>
      </tr>
      <tr>
      <td>19</td>
      <td>
      <p><b>substring()</b></p>
      <p>Get a substring of a String. The starting index is inclusive (the corresponding character is included in the substring), but the optional ending index is exclusive (the corresponding character is not included in the substring). If the ending index is omitted, the substring continues to the end of the String.</p>
      </td>
      </tr>
      <tr>
      <td>20</td>
      <td>
      <p><b>toInt()</b></p>
      <p>Converts a valid String to an integer. The input string should start with an integer number. If the string contains non-integer numbers, the function will stop performing the conversion.</p>
      </td>
      </tr>
      <tr>
      <td>21</td>
      <td>
      <p><b>toFloat()</b></p>
      <p>Converts a valid String to a float. The input string should start with a digit. If the string contains non-digit characters, the function will stop performing the conversion. For example, the strings "123.45", "123", and "123fish" are converted to 123.45, 123.00, and 123.00 respectively. Note that "123.456" is approximated with 123.46. Note too that floats have only 6-7 decimal digits of precision and that longer strings might be truncated.</p>
      </td>
      </tr>
      <tr>
      <td>22</td>
      <td>
      <p><b>toLowerCase()</b></p>
      <p>Get a lower-case version of a String. As of 1.0, toLowerCase() modifies the string in place rather than returning a new.</p>
      </td>
      </tr>
      <tr>
      <td>23</td>
      <td>
      <p><b>toUpperCase()</b></p>
      <p>Get an upper-case version of a String. As of 1.0, toUpperCase() modifies the string in place rather than returning a new one.</p>
      </td>
      </tr>
      <tr>
      <td>24</td>
      <td>
      <p><b>trim()</b></p>
      <p>Get a version of the String with any leading and trailing whitespace removed. As of 1.0, trim() modifies the string in place rather than returning a new one.</p>
      </td>
      </tr>
      </table>
      <p>The next sketch uses some C string functions.</p>
      <h3>Example</h3>
      <code><pre>void setup() {
         char str[] = "This is my string"; // create a string
         char out_str[40]; // output from string functions placed here
         int num; // general purpose integer
         Serial.begin(9600);
      
         // (1) print the string
         Serial.println(str);
      
         // (2) get the length of the string (excludes null terminator)
         num = strlen(str);
         Serial.print("String length is: ");
         Serial.println(num);
      
         // (3) get the length of the array (includes null terminator)
         num = sizeof(str); // sizeof() is not a C string function
         Serial.print("Size of the array: ");
         Serial.println(num);
      
         // (4) copy a string
         strcpy(out_str, str);
         Serial.println(out_str);
      
         // (5) add a string to the end of a string (append)
         strcat(out_str, " sketch.");
         Serial.println(out_str);
         num = strlen(out_str);
         Serial.print("String length is: ");
         Serial.println(num);
         num = sizeof(out_str);
         Serial.print("Size of the array out_str[]: ");
         Serial.println(num);
      }
      
      void loop() {
      
      }
      </pre></code>
      <h3>Result</h3>
      <code><pre>This is my string
      String length is: 17
      Size of the array: 18
      This is my string
      This is my string sketch.
      String length is: 25
      Size of the array out_str[]: 40
      </pre></code>
      <p>The sketch works in the following way.</p>
      <h3>Print the String</h3>
      <p>The newly created string is printed to the Serial Monitor window as done in previous sketches.</p>
      <h3>Get the Length of the String</h3>
      <p>The strlen() function is used to get the length of the string. The length of the string is for the printable characters only and does not include the null terminator.</p>
      <p>The string contains 17 characters, so we see 17 printed in the Serial Monitor window.</p>
      <h3>Get the Length of the Array</h3>
      <p>The operator sizeof() is used to get the length of the array that contains the string. The length includes the null terminator, so the length is one more than the length of the string.</p>
      <p>sizeof() looks like a function, but technically is an operator. It is not a part of the C string library, but was used in the sketch to show the difference between the size of the array and the size of the string (or string length).</p>
      <h3>Copy a String</h3>
      <p>The strcpy() function is used to copy the str[] string to the out_num[] array. The strcpy() function copies the second string passed to it into the first string. A copy of the string now exists in the out_num[] array, but only takes up 18 elements of the array, so we still have 22 free char elements in the array. These free elements are found after the string in memory.</p>
      <p>The string was copied to the array so that we would have some extra space in the array to use in the next part of the sketch, which is adding a string to the end of a string.</p>
      <h3>Append a String to a String (Concatenate)</h3>
      <p>The sketch joins one string to another, which is known as concatenation. This is done using the strcat() function. The strcat() function puts the second string passed to it onto the end of the first string passed to it.</p>
      <p>After concatenation, the length of the string is printed to show the new string length. The length of the array is then printed to show that we have a 25-character long string in a 40 element long array.</p>
      <p>Remember that the 25-character long string actually takes up 26 characters of the array because of the null terminating zero.</p>
      <h2>Array Bounds</h2>
      <p>When working with strings and arrays, it is very important to work within the bounds of strings or arrays. In the example sketch, an array was created, which was 40 characters long, in order to allocate the memory that could be used to manipulate strings.</p>
      <p>If the array was made too small and we tried to copy a string that is bigger than the array to it, the string would be copied over the end of the array. The memory beyond the end of the array could contain other important data used in the sketch, which would then be overwritten by our string. If the memory beyond the end of the string is overrun, it could crash the sketch or cause unexpected behavior.</p>
    </section>
    <section class="main-section" id="string_object">
      <header>String Object</header>
      <p>The second type of string used in Arduino programming is the String Object.</p>
      <h2>What is an Object?</h2>
      <p>An object is a construct that contains both data and functions. A String object can be created just like a variable and assigned a value or string. The String object contains functions (which are called "methods" in object oriented programming (OOP)) which operate on the string data contained in the String object.</p>
      <p>The following sketch and explanation will make it clear what an object is and how the String object is used.</p>
      <h3>Example</h3>
      <code><pre>void setup() { 
         String my_str = "This is my string.";
         Serial.begin(9600);
      
         // (1) print the string
         Serial.println(my_str);
      
         // (2) change the string to upper-case
         my_str.toUpperCase();
         Serial.println(my_str);
      
         // (3) overwrite the string
         my_str = "My new string.";
         Serial.println(my_str);
      
         // (4) replace a word in the string
         my_str.replace("string", "Arduino sketch");
         Serial.println(my_str);
      
         // (5) get the length of the string
         Serial.print("String length is: ");
         Serial.println(my_str.length());
      }
      
      void loop() { 
      
      }
      </pre></code>
      <h3>Result</h3>
      <code><pre>This is my string.
      THIS IS MY STRING.
      My new string.
      My new Arduino sketch.
      String length is: 22
      </pre></code>
      <p>A string object is created and assigned a value (or string) at the top of the sketch.</p>
      <code><pre>String my_str = "This is my string." ;
      </pre></code>
      <p>This creates a String object with the name <b>my_str</b> and gives it a value of "This is my string.".</p>
      <p>This can be compared to creating a variable and assigning a value to it such as an integer −</p>
      <code><pre>int my_var = 102;
      </pre></code>
      <p>The sketch works in the following way.</p>
      <h3>Printing the String</h3>
      <p>The string can be printed to the Serial Monitor window just like a character array string.</p>
      <h3>Convert the String to Upper-case</h3>
      <p>The string object my_str that was created, has a number of functions or methods that can be operated on it. These methods are invoked by using the objects name followed by the dot operator (.) and then the name of the function to use.</p>
      <code><pre>my_str.toUpperCase();
      </pre></code>
      <p>The <b>toUpperCase()</b> function operates on the string contained in the <b>my_str</b> object which is of type String and converts the string data (or text) that the object contains to upper-case characters. A list of the functions that the String class contains can be found in the Arduino String reference. Technically, String is called a class and is used to create String objects.</p>
      <h3>Overwrite a String</h3>
      <p>The assignment operator is used to assign a new string to the <b>my_str</b> object that replaces the old string</p>
      <code><pre>my_str = "My new string." ;
      </pre></code>
      <p>The assignment operator cannot be used on character array strings, but works on String objects only.</p>
      <h3>Replacing a Word in the String</h3>
      <p>The replace() function is used to replace the first string passed to it by the second string passed to it. replace() is another function that is built into the String class and so is available to use on the String object my_str.</p>
      <h3>Getting the Length of the String</h3>
      <p>Getting the length of the string is easily done by using length(). In the example sketch, the result returned by length() is passed directly to Serial.println() without using an intermediate variable.</p>
      <h2>When to Use a String Object</h2>
      <p>A String object is much easier to use than a string character array. The object has built-in functions that can perform a number of operations on strings.</p>
      <p>The main disadvantage of using the String object is that it uses a lot of memory and can quickly use up the Arduinos RAM memory, which may cause Arduino to hang, crash or behave unexpectedly. If a sketch on an Arduino is small and limits the use of objects, then there should be no problems.</p>
      <p>Character array strings are more difficult to use and you may need to write your own functions to operate on these types of strings. The advantage is that you have control on the size of the string arrays that you make, so you can keep the arrays small to save memory.</p>
      <p>You need to make sure that you do not write beyond the end of the array bounds with string arrays. The String object does not have this problem and will take care of the string bounds for you, provided there is enough memory for it to operate on. The String object can try to write to memory that does not exist when it runs out of memory, but will never write over the end of the string that it is operating on.</p>
      <h3>Where Strings are Used</h3>
      <p>In this chapter we studied about the strings, how they behave in memory and their operations.</p>
      <p>The practical uses of strings will be covered in the next part of this course when we study how to get user input from the Serial Monitor window and save the input in a string.</p>
    </section>
    <section class="main-section" id="time">
      <header>Time</header>
      <p>Arduino provides four different time manipulation functions. They are −</p>
      <table>
      <tr>
      <th>S.No.</th>
      <th >Function &amp; Description</th>
      </tr>
      <tr>
      <td>1</td>
      <td>
      <p>The way the <b>delay()</b> function works is pretty simple. It accepts a single integer (or number) argument. This number represents the time (measured in milliseconds).</p>
      </td>
      </tr>
      <tr>
      <td>2</td>
      <td>
      <p>The <b>delayMicroseconds()</b> function accepts a single integer (or number) argument. There are a thousand microseconds in a millisecond, and a million microseconds in a second.</p>
      </td>
      </tr>
      <tr>
      <td>3</td>
      <td>
      <p>This function is used to return the number of milliseconds at the time, the Arduino board begins running the current program.</p>
      </td>
      </tr>
      <tr>
      <td>4</td>
      <td>
      <p>The micros() function returns the number of microseconds from the time, the Arduino board begins running the current program. This number overflows i.e. goes back to zero after approximately 70 minutes.</p>
      </td>
      </tr>
      </table>
    </section>
    <section class="main-section" id="arrays">
      <header>Arrays</header>
      <p>An array is a consecutive group of memory locations that are of the same type. To refer to a particular location or element in the array, we specify the name of the array and the position number of the particular element in the array.</p>
      <p>The illustration given below shows an integer array called C that contains 11 elements. You refer to any one of these elements by giving the array name followed by the particular element’s position number in square brackets ([]). The position number is more formally called a subscript or index (this number specifies the number of elements from the beginning of the array). The first element has subscript 0 (zero) and is sometimes called the zeros element.</p>
      <p>Thus, the elements of array C are C[0] (pronounced “C sub zero”), C[1], C[2] and so on. The highest subscript in array C is 10, which is 1 less than the number of elements in the array (11). Array names follow the same conventions as other variable names.</p>
      <img src="images/technical-doc/elements_of_array.png" alt="Elements of Array">
      <p>A subscript must be an integer or integer expression (using any integral type). If a program uses an expression as a subscript, then the program evaluates the expression to determine the subscript. For example, if we assume that variable a is equal to 5 and that variable b is equal to 6, then the statement adds 2 to array element C[11].</p>
      <p>A subscripted array name is an lvalue, it can be used on the left side of an assignment, just as non-array variable names can.</p>
      <p>Let us examine array C in the given figure, more closely. The name of the entire array is C. Its 11 elements are referred to as C[0] to C[10]. The value of C[0] is -45, the value of C[1] is 6, the value of C[2] is 0, the value of C[7] is 62, and the value of C[10] is 78.</p>
      <p>To print the sum of the values contained in the first three elements of array C, we would write −</p>
      <code><pre>Serial.print (C[ 0 ] + C[ 1 ] + C[ 2 ] );
      </pre></code>
      <p>To divide the value of C[6] by 2 and assign the result to the variable x, we would write −</p>
      <code><pre>x = C[ 6 ] / 2;
      </pre></code>
      <h2>Declaring Arrays</h2>
      <p>Arrays occupy space in memory. To specify the type of the elements and the number of elements required by an array, use a declaration of the form −</p>
      <code><pre>type arrayName [ arraySize ] ;
      </pre></code>
      <p>The compiler reserves the appropriate amount of memory. (Recall that a declaration, which reserves memory is more properly known as a definition). The arraySize must be an integer constant greater than zero. For example, to tell the compiler to reserve 11 elements for integer array C, use the declaration −</p>
      <code><pre>int C[ 12 ]; // C is an array of 12 integers
      </pre></code>
      <p>Arrays can be declared to contain values of any non-reference data type. For example, an array of type string can be used to store character strings.</p>
      <h2>Examples Using Arrays</h2>
      <p>This section gives many examples that demonstrate how to declare, initialize and manipulate arrays.</p>
      <h3>Example 1: Declaring an Array and using a Loop to Initialize the Array’s Elements</h3>
      <p>The program declares a 10-element integer array <b>n</b>. Lines a–b use a <b>For</b> statement to initialize the array elements to zeros. Like other automatic variables, automatic arrays are not implicitly initialized to zero. The first output statement (line c) displays the column headings for the columns printed in the subsequent for statement (lines d–e), which prints the array in tabular format.</p>
      <p><b>Example</b></p>
      <code><pre>int n[ 10 ] ; // n is an array of 10 integers
      
      void setup () {
      
      }
      
      void loop () {
         for ( int i = 0; i &lt; 10; ++i ) // initialize elements of array n to 0 {
      n[ i ] = 0; // set element at location i to 0
      Serial.print (i) ;
      Serial.print (‘\r’) ;
         }
         for ( int j = 0; j &lt; 10; ++j ) // output each array element's value {
      Serial.print (n[j]) ;
      Serial.print (‘\r’) ;
         } 
      }
      </pre></code>
      <p><b>Result</b> − It will produce the following result −</p>
      <table>
      <tr>
      <th >Element</th>
      <th >Value</th>
      </tr>
      <tr>
      <td>
      <p>0</p>
      <p>1</p>
      <p>2</p>
      <p>3</p>
      <p>4</p>
      <p>5</p>
      <p>6</p>
      <p>7</p>
      <p>8</p>
      <p>9</p>
      </td>
      <td>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      <p>0</p>
      </td>
      </tr>
      </table>
      <h3>Example 2: Initializing an Array in a Declaration with an Initializer List</h3>
      <p>The elements of an array can also be initialized in the array declaration by following the array name with an equal-to sign and a brace-delimited comma-separated list of initializers. The program uses an initializer list to initialize an integer array with 10 values (line a) and prints the array in tabular format (lines b–c).</p>
      <p><b>Example</b></p>
      <code><pre>// n is an array of 10 integers
      int n[ 10 ] = { 32, 27, 64, 18, 95, 14, 90, 70, 60, 37 } ;
      
      void setup () {
      
      }
      
      void loop () {
         for ( int i = 0; i &lt; 10; ++i ) {
      Serial.print (i) ;
      Serial.print (‘\r’) ;
         }
         for ( int j = 0; j &lt; 10; ++j ) // output each array element's value {
      Serial.print (n[j]) ;
      Serial.print (‘\r’) ;
         } 
      }
      </pre></code>
      <p><b>Result</b> − It will produce the following result −</p>
      <table>
      <tr>
      <th >Element</th>
      <th >Value</th>
      </tr>
      <tr>
      <td>
      <p>0</p>
      <p>1</p>
      <p>2</p>
      <p>3</p>
      <p>4</p>
      <p>5</p>
      <p>6</p>
      <p>7</p>
      <p>8</p>
      <p>9</p>
      </td>
      <td>
      <p>32</p>
      <p>27</p>
      <p>64</p>
      <p>18</p>
      <p>95</p>
      <p>14</p>
      <p>90</p>
      <p>70</p>
      <p>60</p>
      <p>37</p>
      </td>
      </tr>
      </table>
      <h3>Example 3: Summing the Elements of an Array</h3>
      <p>Often, the elements of an array represent a series of values to be used in a calculation. For example, if the elements of an array represent exam grades, a professor may wish to total the elements of the array and use that sum to calculate the class average for the exam. The program sums the values contained in the 10-element integer array <b>a</b>.</p>
      <p><b>Example</b></p>
      <code><pre>const int arraySize = 10; // constant variable indicating size of array
      int a[ arraySize ] = { 87, 68, 94, 100, 83, 78, 85, 91, 76, 87 };
      int total = 0;
      
      void setup () {
      
      }
      void loop () {
         // sum contents of array a
         for ( int i = 0; i &lt; arraySize; ++i )
      total += a[ i ];
         Serial.print (“Total of array elements : ”) ;
         Serial.print(total) ;
      }
      </pre></code>
      <p><b>Result</b> − It will produce the following result −</p>
      <code><pre>Total of array elements: 849
      </pre></code>
      <p>Arrays are important to Arduino and should need a lot more attention. The following important concepts related to array should be clear to a Arduino −</p>
      <table>
      <tr>
      <th>S.NO.</th>
      <th >Concept &amp; Description</th>
      </tr>
      <tr>
      <td>1</td>
      <td><p>To pass an array argument to a function, specify the name of the array without any brackets.</p></td> 
      </tr>
      <tr>
      <td>2</td>
      <td><p>Arrays with two dimensions (i.e., subscripts) often represent tables of values consisting of information arranged in rows and columns.</p></td> 
      </tr>
      </table>
    </section>

  </main>
</body>
</html>